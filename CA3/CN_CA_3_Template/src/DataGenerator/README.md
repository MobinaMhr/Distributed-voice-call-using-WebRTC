# DataGenerator

The `DataGenerator` class is designed to generate packets based on a ***Poisson distribution**. It provides methods for setting parameters, generating uniform random numbers, calculating Poisson probability mass functions (PMF), and generating packet distributions. The class inherits from QObject.

in the `setParameters()` method of this class, some input parameters are set as bellow:
```cpp
void DataGenerator::setParameters(int cycleCount, int packetCount, int pcCount, double lambda, float threshold) {
    this->cycleCount = cycleCount;
    this->packetCount = packetCount;
    this->pcCount = pcCount;
    this->lambda = lambda;

    this->devidingStep = calculate_deviding_step(threshold);
}
```
Note that the devidingStep field is set by the value generated by the `calculate_deviding_step()` method.
The `lmabda` field is used as a parameter of Poisson distribution, which is described bellow. 


The `getUniformRandom()` method returns a float number in the range of (0.0, 1.0). This number will be used as a probability amount.
```cpp
float DataGenerator::getUniformRandom() {
    std::uniform_real_distribution<float> uniformDist(0.0, 1.0);
    return uniformDist(generator);
}
```

The `poissonPMF()` method will return the calculated Poission PMF value for a given x.
```cpp
double DataGenerator::poissonPMF(int x) {
    return qExp(-this->lambda) * qPow(this->lambda, x) / tgamma(x + 1);
}
```

The `poissonInverseCDF()` method will give the inverse of CDF of the Poisson distribution for a given probablity of `p`.
```cpp
int DataGenerator::poissonInverseCDF(float p) {
    // poissonInverseCDF
    double cumulative = 0.0;
    int x = 0;

    while (cumulative < p) {
        cumulative += poissonPMF(x);
        if (cumulative >= p) {
            return x;
        }
        x++;
    }
    return x;
}
```

The `generatePacketDistribution()` method will generate a distribution of packets across cycles based on the Poisson distribution.
This method loops over the `packetCount` and tries to create a Poisson distribution for each cycle. Note that in each cycle, there should not be more than `pcCount` packet receivers. 

At this time a `distributionGenerated` signall is emmited. Which we are not sure to keep it or not. 
At the end the created distribution is returned.
```cpp
QVector<int> DataGenerator::generatePacketDistribution() {
    QVector<int> distribution(cycleCount, 0);

    for (int i = 0; i < packetCount; ++i) {
        bool valid = false;
        while (!valid) {
            int cycle = getRandomCycle();

            if (distribution[cycle] < pcCount) {
                ++distribution[cycle];
                valid = true;
            }
        }
    }

    Q_EMIT distributionGenerated(distribution);
    return distribution;
}
```

The `calculate_deviding_step()` method divides the whole created border by possonInverseCDF by the `cycleCount` and returns the devidingStep filed used by `getRandomCycle()` method.
```cpp
int DataGenerator::calculate_deviding_step(float tr) {
    int border = poissonInverseCDF(tr);
    return border / this->cycleCount;
}
```

The `getRandomCycle()` method gets the output of poissonInverseCDF method and uses this amount to decide on the random cycle.
This generated cycle will be used in the `generatePacketDistribution` method to decide to increament on what cycle in the distribution.
```cpp
int DataGenerator::getRandomCycle() {
    int temp = poissonInverseCDF(getUniformRandom());
    int cycle = -1;
    for (int i = 0; i < this->cycleCount - 1; ++i) {
        if (temp >= i * this->devidingStep && temp < (i + 1) * this->devidingStep) {
            cycle = i;
            break;
        }
    }
    if (cycle == -1)
        cycle = this->cycleCount - 1;
    return cycle;
}
```